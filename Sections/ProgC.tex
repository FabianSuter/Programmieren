\section{ProgC}

    \subsection{Wichtige Kurzbefehle}
		\begin{tabular}{ll}
			\verb|cd "Path"| & Pfad anwählen \\
			\verb|cd ..| & um eine Ebene nach oben (zurück) \\
			\verb|mkdir "Ordnername"| & Ordner erstellen \\
			\verb|rmkdir "Ordnername"| & Ordner löschen \\
			\verb|rm -rf *| & Alles innerhalb vom aktuellen Ordner löschen \\
			\verb|rm "Datei"| & Datei löschen \\
			\verb|mv "Name alt" "Name neu"| & Datei umbenennen \\
			\verb|cp "Datei alt" "Datei neu"| & Datei kopieren und benennen \\
			\verb|clang -Wall -o "Outputname" "Inputdatei"| & clang-Compiler mit Warnungen \\
			\verb|clang -Wall -o "Outputname" "Inputdatei" -lm| & -lm für Mathebibliothek \\
			\verb|ls| & Listet alle Files im akt. Verzeichnis auf \\
			\verb|ls -l| & Inkl. Informationen wie Grösse u.a. \\
			\verb|ls -a| & Inkl. versteckten Dateien \\
			\verb|ls -al| & Beide Varianten \\
		\end{tabular}

	\subsection{Zahlensysteme}
		\begin{tabular}{|l|l|l|l|l|l|l|l|}
			\hline
			$2^0$ = 1 & $2^1$ = 2 & $2^2$ = 4 & $2^3$ = 8 & $2^4$ = 16 & $2^5$ = 32 & $2^6$ = 64 & $2^7$ = 128 \\
			\hline
		\end{tabular}

		\begin{tabular}{|l|l|l|l|}
			\hline
			\textbf{Grösse} & \textbf{Abk.} & \textbf{Genauer Wert} & \textbf{Näherung} \\
			\hline
			Kilobyte & kB & $2^{10}$ = 1024 Bytes & $10^3$ Bytes \\
			\hline
			Megabyte & MB & $2^{20}$ = 1 048 576 Bytes & $10^6$ Bytes \\
			\hline
			Gigabyte & GB & $2^{30}$ = 1 073 741 824 Bytes & $10^9$ Bytes \\
			\hline
			Terabyte & TB & $2^{40}$ = 1 099 511 627 776 Bytes & $10^12$ Bytes \\ 
			\hline
		\end{tabular}

		\begin{tabular}{|l|llllll|}
			\hline
			Oktal & 3 Bits & $X_8$ & $X_O$ & $X_q$ & $X_oct$ & $0X$ \\
			\hline
			Hex & 4 Bits   & $X_16$ & $X_h$ & $XH$ & $X_hex$ & 0xX \\
			\hline
		\end{tabular}

		\paragraph{Hexadezimal}
			\begin{tabular}{llllllllllllllll}
				0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 \\
				0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & A & B & C & D & E & F \\
			\end{tabular}
			
		\paragraph{ASCII (7-Bit)}
			
			Ordnet gängigen Schriftzeichen einen Zahlenwert zu, um diese in einem Digitalrechner präsentieren zu können.
			Die Tabelle ist wichtig, um für geg. Schriftzeichen den repräsentierten Zahlenwert zu ermitteln (und umgekehrt).

			Nachfolger: Unicode (8-, 16-, 32-Bit)
	
	\subsection{Datentypen}
		\subsubsection{Datentypen}
			\begin{tabular}{lccll}
				\textit{Typ} & \textit{Anz. Bytes} & \textit{Bereich} & \textit{scanf} & \textit{Spezielles} \\
				\hline
				\textbf{Ganze Zahlen} & & & & \\
				byte & 1  & 0 ... +255 & & \\
				short & 2 & $-2^{15} ... +2^{15}-1$ & \verb|%d; %i| & Hex: \verb|%x; %X| \\
				int & 4 & $-2^{31} ... +2^{31}-1$ & \verb|%d| & Hex: \verb|%x; %X| \\
				long & 8  & $-2^{63} ... +2^{63}-1$ & \verb|%ld; %li| & Hex: \verb|%x; %X| \\
				\hline
				\textbf{Dezimalzahlen} & & & (Expon.: \verb|%e|) & \\
				float  & 4  & $1.2E-38$ ... $3.4E+38$ & \verb|%f| & 6 Dez.stellen \\ %6 dez
				double & 8  & $2.3E-308$ ... $1.7E+308$ & \verb|%lf| & 15 Dez.stellen \\ %15 dez
				\hline
				\textbf{Spezial} & & & & \\
				char    & 1 & Einzelne Buchstaben & \verb|%c| & \\
				boolean & 1 & True / False & & \\
				string  &   & Zeichenkette; Text & \verb|%s| & \\
				\hline
				\textbf{Vorzeichen, Versch.} & & & & \\
				unsigned char          & 1 & 0 ... +255    & \verb|%c| & \\
				signed char            & 1 & -128 ... +127 & \verb|%c| & \\
				unsigned int           & 4 & 0 ... $+2^{32}-1$ & \verb|%u| & \\
				short int              & 2 & $-2^{15} ... +2^{15}-1$ & \verb|%hd| & \\
				unsigned short int     & 2 & 0 ... $+2^{16}-1$ & \verb|%hu| & \\
				long int               & 4 & $-2^{31} ... +2^{31}-1$ & \verb|%ld| & \\
				unsigned long int      & 4 & 0 ... $+2^{32}-1$ & \verb|%lu| & \\
				long long int          & 8 & $-2^{63} ... +2^{63}-1$ & \verb|%lld| & \\
				unsigned long long int & 8 & 0 ... $+2^{64}-1$ & \verb|%llu| & \\
				long double            & 16 & $3.3E-4932$ ... $1.1E+4932$ & \verb|%Lf| & 18 Dez.stellen \\ %18 dez
			\end{tabular}
			
 			\textbf{Ganzzahlen} können überlaufen!

			\textbf{Gleitpunktzahlen} haben meist Rundungsfehler. Nie auf Gleichheit prüfen!

		\subsubsection{Typumwandlung}
			\verb|float f = 41.7;|\\
			Implizit: Eine Kommazahl ohne \verb|f| am Ende hat den Typ \verb|double|
			\\
			\\
			\verb|int x = (int) f;|\\
			Explizit: x hat den Wert 41, Nachkommastellen werden abgeschnitten

		\subsubsection{Namen}
			\begin{minipage}{0.35\linewidth}
				\begin{itemize}
					\item Idealerweise mit Kleinbuchstaben beginnen
					\item Buchstaben, Ziffern, Underscore
					\item Camelcase
				\end{itemize}
			\end{minipage}
			\hfill
			\begin{minipage}{0.6\linewidth}
				\includegraphics[width=1\linewidth]{Bilder/verbotene_namen.png}
			\end{minipage}

		\subsubsection{Wertebereich}
			\begin{tabular}{lll}
				unsigned & 0...$(2^n-1)$               & n=8 : 0...255 \\
				signed   & $-2^{n-1}...+(2^{n-1}-1)$ & n=8 : -128...+127 \\
			\end{tabular}
		
	\subsection{Variablen}
		\begin{minipage}{1\linewidth}
			\includegraphics[width=1\linewidth]{Bilder/sichtbarkeit_variablen.png}
		\end{minipage}

	\subsection{Schleifen}
		\begin{itemize}
			\item \verb|for|-Schleife: Für Zählschleifen, bzw. wenn die Anzahl Durchläufe bekannt ist
			\item \verb|do...while|-Schleife: Keine Zählschleife, min. 1 Durchlauf
			\item \verb|while|-Schleife: In allen anderen Fällen	
		\end{itemize}

		\subsubsection{For-Schleife}
			\begin{minipage}{.45\linewidth}
				\includegraphics[width=0.95\linewidth]{Bilder/forschleife.png}
			\end{minipage}
			\hfill
			\begin{minipage}{.5\linewidth}
				For-Schleife
			\end{minipage}

		\subsubsection{Switch-Schleife}
			\begin{minipage}{.45\linewidth}
				\includegraphics[width=0.95\linewidth]{Bilder/Switch.png}
			\end{minipage}
			\hfill
			\begin{minipage}{.5\linewidth}
				Switch-Schleife
			\end{minipage}

		\subsubsection{Do-While-Schleife}
			\begin{minipage}{.45\linewidth}
				\includegraphics[width=0.95\linewidth]{Bilder/dowhile.png}
			\end{minipage}
			\hfill
			\begin{minipage}{.5\linewidth}
				Do-While-Schleife
			\end{minipage}

		\subsubsection{While-Schleife}
			\begin{minipage}{.45\linewidth}
				\includegraphics[width=0.5\linewidth]{Bilder/while1.png}
				\includegraphics[width=0.5\linewidth]{Bilder/while2.png}
			\end{minipage}
			\hfill
			\begin{minipage}{.5\linewidth}
				While-Schleife
			\end{minipage}

		\subsubsection{Sprunganweisungen}
			\begin{itemize}
				\item \verb|break|: Schleifen abbrechen, zurückhaltend einsetzen!
				\item \verb|continue|: nächsten Schleifendurchgang starten, sehr zurückhaltend einsetzen!
				\item \verb|return|: aus Funktion zum Aufruf springen
				\item \verb|goto|: zu einer Marke springen, VERMEIDEN!
			\end{itemize}

	\subsection{Pointer}
		\subsubsection{Nullpointer}
			\begin{minipage}{1\linewidth}
				\includegraphics[width=0.95\linewidth]{Bilder/nullpointer.png}
			\end{minipage}

		\subsubsection{Ref- und Dereferenzieren}
			\begin{tabular}{l|l}
				\textbf{Referenzieren} & \textbf{Dereferenzieren} \\
				\includegraphics[height=3.2cm]{Bilder/referenzieren.png} &  \includegraphics[height=3.2cm]{Bilder/dereferenzieren.png} \\
				\textbf{\&} verknüpft den Pointer mit einer Variable   &  \textbf{*} liefert den Inhalt der Speicherzelle der Adr. \\
			\end{tabular}

			\begin{minipage}{1\linewidth}
				\includegraphics[width=0.5\linewidth]{Bilder/vergl-ref-deref.png}
			\end{minipage}

			%ToDo: Prüfungsbeispiel reinpappen

		\subsubsection{Zuweisungen}
			\begin{lstlisting}[language=C]
int     a;
double  d;
int*    pi = &a;
int*    pj;
double* pd = &d;
void*   pv; 

pv = pd;	 //erlaubt, da pv void-Pointer
pj = pi;	 //erlaubt, gleicher Typ
pd = pi;	 //nicht erlaubt, untersch. Typen
pi = pv;	 //erlaubt, da pv void-Pointer
pd = (double*)pj;//erlaubt da Type-Cast
			\end{lstlisting}
		
	\subsection{Arrays}
			Arrays arbeiten mit Array-Index. In C beginnt dieser bei 0 und endet bei $n-1$:
			\begin{lstlisting}[language=C]
int alpha[5];  // Array "alpha" mit 5 El. vom Typ int
alpha[0] = 14; // 1. Element (Index 0) = 14
alpha[4] = 3;  // letztes Element (Index 4)
alpha[5] = 4;  // Bereichsueberschr.! -> undefined behaviour
			\end{lstlisting}
			\textbf{Memorymap:}\\
				\begin{minipage}{1\linewidth}
					\includegraphics[width=0.5\linewidth]{Bilder/arr-mem-map.png}
				\end{minipage}

		\subsubsection{Initialisierungsvarianten}
			\begin{lstlisting}[language=C]
int a1[5] = {0, 8, 5, 1, 2};
int a2[5] = {1, 8};         //Index 1 bis 3 sind auf "0"
int a3[5] = {};             //Alle Elemente sind auf "0"
int a4[] = {12, 3, 2};      //Groesse anhand der Anz. Elemente => "[3]"
			\end{lstlisting}

		\subsubsection{Grösse eines Arrays}
			\verb|sizeof()| liefert bei Arrays die Grösse in \textbf{Bytes}\\
			Zur Bestimmung der Anzahl Elemente kann die Grösse des Arrays durch die Grösse eines Wertes geteilt werden:
			\begin{lstlisting}[language=C]
int main() {
	int arr[] = {4, 3, 2, 1};
	printf("arr hat %lu Elemente\n", sizeof(arr)/siezof(arr[0]));
	return 0;
}
			\end{lstlisting}

		\subsubsection{char - Arrays}
			Ein String in C ist immer ein Array von Zeichen. (\verb|char| - Array).\\
			Ein String in C muss \textbf{immer} mit \verb|\0| abgeschlossen werden und braucht eine Stelle des Arrays!
			\begin{lstlisting}[language=C]
// Folgende Varianten sind gleichwertig:
char name[15] = {1, 2, 3, 4, 5, 0};
char name[15] = {'M', 'e', 'i' 'e', 'r', '\0'};
char name[15] = "Meier";
			\end{lstlisting}

		\subsubsection{Array mit Schleife durchlaufen (Bsp.)}
			\begin{lstlisting}[language=C]
enum{groesse = 5};
int alpha[groesse];

for(int i = 0; i < groesse; ++i)
	printf("%d \n", alpha[i]) // keine "{}", da nur eine Zeile
			\end{lstlisting}

		\subsubsection{Weitere Array-Regeln}
			\begin{itemize}
				\item Ein Array als Ganzes kann keine Werte annehmen, nur einzelne Elemente
				\item Die üblichen Operatoren können nicht auf Arrays angewendet werden
				\item Funktionen in C können \textbf{keine} Arrays als Aufrufparameter haben!
				\item Wird bei einem Funktionsaufruf ein Array als Parameter übergeben, wird das Array \textit{implizit zu einem Pointer auf das Element an Index 0 konvertiert}
				\item Der Name des Arrays kann als \textit{konst. Adresse} von Index 0 des Arrays verwendet werden: \verb|alpha[i] == *(alpha +i)| \\
				\textbf{Achtung!}
				\begin{itemize}
					\item Der Pointer \textbf{ptr} bewegt sich bei \textbf{ptr$+$n} immer um \textbf{n * sizeof(Typ)} Bytes!
					\item Wenn der Pointer über den Bereich hinauszeigt, ist das zwar legal, das Resultat ist aber undefiniert.
				\end{itemize}
				\item Zuweisung eines Arrays auf einen Pointer:\\
				\includegraphics[height=2cm]{Bilder/arr-ptr-zuweisung.png}
				\item Benutzung eines Pointers im Array-Stil:\\
				\includegraphics[height=2cm]{Bilder/ptr-im-arr-stil.png}	
			\end{itemize}

	\subsection{Code-Snippets}
		\subsubsection{Array und Pointer}
			\begin{lstlisting}[language=C]
#include <stdio.h>

int main(){
	enum{array_size = 6};
	int test[array_size] = {1,2,3,4,5,6};
	for(int i =0; i<array_size; ++i)
		printf("Element %u: %i\n", i, test[i]);
	
	printf("Groesster: %d", *findAbsMax(test, array_size));
	return 0;
}
			\end{lstlisting}
			Main-Funktion zum Finden eines \textbf{betragsmässig} grössten Wertes innerhalb eines Arrays.

			\begin{lstlisting}[language=C]
int* findAbsMax(int* arr, size_t size){
	int* max_ptr = &arr[0];
	for(size_t i = 0; i < size; ++i){
		if((arr[i] >=0 && *max_ptr >=0 && arr[i] > *max_ptr)
		|| (arr[i] <=0 && *max_ptr <=0 && arr[i] < *max_ptr)
		|| (arr[i] >=0 && *max_ptr <=0 && arr[i] > *max_ptr * -1)
		|| (arr[i] <=0 && *max_ptr >=0 && arr[i] * -1 > *max_ptr))
			max_ptr = &arr[i];
	}
	return max_ptr;
}
			\end{lstlisting}